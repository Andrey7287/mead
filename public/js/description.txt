Александр, доброе утро !

Вот мои ответы на тестовое задание.

1е задание: 


Невозможно подписаться на события генерируемые экземпляром XMLHttpRequest не зная имени переменной, ссылающейся на него. Также не существует способа вызвать метод сatch для любого написанного в коде промиса, если речь идёт о fetch api.  Задачу которую вы поставили невозможно решить.

2е задание: 

0. Организация кода, а точнее её отсутствие. Код представляет собой набор зависимых друг от друга функций. Для использования необходимо прямое копирование этих функций в проект, что достаточно неудобно. Не испольуется инкапсуляция, все функции разворачиваются в общем скопе засоряя его кучей переменных, что патенциально ведёт проблемам. Используются конструкторы, однако нет практической пользы от них, с таким же успехом можно было бы просто создавать объекты.

1. Для jQuerry проектов рациональнее было бы написать плагин, который бы работал так - $('.selector').validator('email'); А так не вижу пользы от её применея, напротив код усложняется.

2. В конструкторах используется функция isEmptyValue, вероятно тоже написанная на jQuerry, которую вы забыли приложить. То что весь код ломается из за её отсутствия не есть хорошо. Опять таки на нативном JS пустая ли строка можно проверить гораздо проще - element.value.trim(). Также есть функция isCellPhone. 
Вот вам и пример проблемы вызванной отсутсвием модульности.

3. Очень много дублирования в коде. Методы set и toString при использовании прототипного наследования можно сделать доступным в каждом классе. Праверку на наличие елемента рациональнее было бы делать в екземпляре Validator`a. 

4. Убрав дублирование в паттернах остаётся всего 1 полезный метод, который по логике должен находится в конструкторе Validator. А в некоторых патернах и вовсе 0, например RadioPattern просто не нужен.

5. Также есть такие недостатки как неиспользуемые переменные, не рациональное применение тернарного оператора, излишния вложенность if конструкций, использование алертов и инлайновых стилии, но все они скорее косметические.

В заключение привожу пример того как можно переписать код с учётом описанных моментов.

Разумеется это 1 конструктор и один вызов конструктора.  

function Validator() {

  //Инкапсуляция приватных методов
  var patterns = {
    email: function (el) {
      // проверка переданного элемента на соответствие паттерну email
    },
    pass : function (el) {
      // проверка переданного элемента на соответствие паттерну password
    },
    default : function (el) {
      // проверка по умолчанию
    }
  };

  // публичный метод 
  this.validate = function (el, pattern) {

    if (!el) return console.warn('Theres is no element for validation!');

    pattern in patterns ? patterns[pattern](el) : patterns.default(el);
  }
  //сеттер для расширения паттернов для проверки тоже не помешает
  Object.defineProperty(this, "addPattern", {
    set: function(obj) {
      patterns[obj.name] = obj.fn;
    }
  });
  
}

//Этот код мы могли бы вынести в отдельный файл и подключать при необходимости. У нас //появляется только одна новая переменная имя которой мы сами задаём. 

var validator = new require('./modules/validator')();

//Проверка на соответствие паттерну 'email' 
validator.validate('selector', 'email');

//Проверка по умолчанию
validator.validate('selector');

//Добавление нового паттерна
var newPattern = {
  name: 'color',
  fn: function(el){
    //code
  }
};
validator.addPattern = newPattern;
validator.validate('selector', 'color');